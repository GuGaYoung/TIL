## 선형검색 알고리즘
선형 검색은 데이터가 모인 집합(배열, 링크드리스트 등)의 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 알고리즘

### 장점
- 데이터를 정렬하거나 따로 건드릴 필요 X
- 구현 방법이 쉽다.

### 단점
- 데이터의 양이 많아질수록 검색에 소요되는 시간도 비례하여 많아진다.
- 처음부터 하나씩, 일일이 바교한다는 점에서 비효율적이다.
(100만개의 데이터가 있을 때 찾고자하는 데이터가 100만번째에 있다면 100만번의 비교를 해야 한다)

### CODE

```js
 // arr : 배열, n : 배열 요소수, key : 찾는 값
function linearSearch(arr, n, key){
	
    let i = 0;
    
    while(true) {
        //검색 실패 (-1을 반환)
        if (i === n) return -1;
        //검색 성공 (인덱스를 반환)
        if (arr[i] === key) return i; 
        i++;
    }
}
```

### n에 비례하는 횟수만큼 검색을 실행하기 때문에 복잡도를 O(n)으로 표기

---

## 이진검색 알고리즘
반으로 나누어서 연산한다.
선형검색의 경우 데이터 집합의 처음에서 시작하여 끝까지 탐색하지만 이진검색은 중간값부터 탐색한다.

### 장점
- 데이터를 계속 반으로 나누면서 연산하기 때문에 처리속도가 매우 빠르다

### 단점
- 정렬된 배열에서만 사용가능 하다

### CODE

```js
 // arr : 배열, key : 찾는 값
function binarySearch(arr, key) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        //검색 성공 (인덱스를 반환)
        if (arr[mid] === key) {
            return mid;
        }
        if (arr[mid] < key) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    //검색 실패 (-1을 반환)
    return -1;
}
```

검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균 값은 log n
검색에 실패한 경우는 [log(n + 1)]회, 검색에 성공한 경우는 log n - 1
이진 검색 알고리즘의 복잡도는 O(log n)